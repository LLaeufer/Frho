use std::str::FromStr;
use std::sync::Arc;

use crate::terms::*;
use crate::values::*;
use crate::logicterms::*;
use crate::types::*;
use crate::utils::*;
use crate::parser_helper::*;

// https://github.com/lalrpop/lalrpop/issues/193
// I need to write my own lexer to not get absolutely destroyed by LALRPOP
// Maybe I have a workaround

// To avoid writing a lexer for this we have to introduce some new rules
// Type variables are preceded by # and all upper case so #TYPE
// TERMs are upper case
// Variables are all lowercase

grammar;

pub Expr: Term = { 
    "let" <l: Label> "=" <t: Expr> => Term::Let(l, Box::new(t)),
    OrTerm, };

OrTerm: Term = {
    <l:OrTerm> "||" <r:AndTerm> => Term::LogicGate(LogicTerm::Or(Box::new(l), Box::new(r))),
    AndTerm,
}

AndTerm: Term = {
    <l:AndTerm> "&&" <r:NotTerm> => Term::LogicGate(LogicTerm::And(Box::new(l), Box::new(r))),
    NotTerm,
}

NotTerm: Term = {
    "!" <t:NotTerm> => Term::LogicGate(LogicTerm::Not(Box::new(t))),
    "-" <t:Term> => Term::LogicGate(LogicTerm::Not(Box::new(t))),
    ComparandTerm,
}

ComparandTerm: Term = {
    <l:ComparandTerm> "==" <r:SummandTerm> => Term::LogicGate(LogicTerm::Eql(Box::new(l), Box::new(r))),
    <l:ComparandTerm> ">" <r:SummandTerm> => Term::LogicGate(LogicTerm::GrT(Box::new(l), Box::new(r))),
    <l:ComparandTerm> "<" <r:SummandTerm> => Term::LogicGate(LogicTerm::LsT(Box::new(l), Box::new(r))),
    <l:ComparandTerm> ">=" <r:SummandTerm> => Term::LogicGate(LogicTerm::GrE(Box::new(l), Box::new(r))),
    <l:ComparandTerm> "<=" <r:SummandTerm> => Term::LogicGate(LogicTerm::LsE(Box::new(l), Box::new(r))),
    SummandTerm,
}

SummandTerm: Term = {
    <l:SummandTerm> "+" <r:FactorTerm> => Term::LogicGate(LogicTerm::Add(Box::new(l), Box::new(r))),
    <l:SummandTerm> "-" <r:FactorTerm> => Term::LogicGate(LogicTerm::Sub(Box::new(l), Box::new(r))),
    FactorTerm,
};

FactorTerm: Term = {
    <l:FactorTerm> "*" <r:Term> => Term::LogicGate(LogicTerm::Mul(Box::new(l), Box::new(r))),
    <l:FactorTerm> "/" <r:Term> => Term::LogicGate(LogicTerm::Div(Box::new(l), Box::new(r))),
    Term,
};

pub Term: Term = {
    <n: Value> => Term::Constant(n),
    <l: Label> => Term::Variable(l),
    "{" "}" => Term::RecordConstruction(vec![]),
    "{" <e: Elements> "}" => Term::RecordConstruction(e),
    "[" <e: Element> "]" => Term::VariantConstruction(e),
    <t:Label> "." <l: Label> => Term::RecordSelection(Box::new(Term::Variable(t)), l),
    <t:TermBlock> "." <l: Label> => Term::RecordSelection(Box::new(Term::Block(t)), l),
    <t: Label> "." <l: Label> "<-" <u: Term> => Term::RecordUpdate(Box::new(Term::Variable(t)), l, Box::new(u)),
    <t: TermBlock> "." <l: Label> "<-" <u: Term> => Term::RecordUpdate(Box::new(Term::Block(t)), l, Box::new(u)),
    "if" <decider: TermBlock> "then" <consequence: TermBlock> "else" <alternative: TermBlock>  => Term::If(Box::new(Term::Block(decider)), Box::new(Term::Block(consequence)), Box::new(Term::Block(alternative))),
    
    FunctionTerm,

    FunctionCallTerm,

    "wrap" "<" <tv: TypeVariable> ":" <tps: Type> ">" <t: Term> => Term::BigLambda(tv, tps, Box::new(t)),
    "unwrap" "<" <tv: TypeVariable> ">" <t: Term> => Term::TypeApplication(Box::new(t), tv),
    "case" <t: Term> "with" "(" "[" <l: Label> ":" <vc: Label> "]" "->" <c: Term> ";" <va: Label> "->" <a: Term> ")" => Term::VariantCase(Box::new(t), l, vc, Box::new(c), va, Box::new(a)),
    "promise" "<" <t: Type> ">" <ts: TermBlock> => Term::Promise(t, Box::new(Term::Block(ts))),
    "print" <t: Term> => Term::Print(Box::new(t)),

    <ts: TermBlock> => Term::Block(ts),
}

FunctionTerm: Term = {
    "fun" <l: Label> "(" <ls: LabelTypes> ")" <block: TermBlock> => Term::Function(l, None, ls, Box::new(Term::Block(block))),
    "fun" <l: Label> "(" ")" <block: TermBlock> => Term::Function(l, None, vec![], Box::new(Term::Block(block))),
    "rec" <l: Label> "(" <ls: LabelTypes> ")" <block: TermBlock> => Term::RecursiveAnonymousFunction(l, None, ls, Box::new(Term::Block(block))),
    "rec" <l: Label> "(" ")" <block: TermBlock> => Term::RecursiveAnonymousFunction(l, None, vec![], Box::new(Term::Block(block))),
    "fun" <l: Label> "(" <ls: LabelTypes> ")" ":" <t:Type> <block: TermBlock> => Term::Function(l, Some(t), ls, Box::new(Term::Block(block))),
    "fun" <l: Label> "(" ")" ":" <t:Type> <block: TermBlock> => Term::Function(l, Some(t), vec![], Box::new(Term::Block(block))),
    "rec" <l: Label> "(" <ls: LabelTypes> ")" ":" <t:Type> <block: TermBlock> => Term::RecursiveAnonymousFunction(l, Some(t), ls, Box::new(Term::Block(block))),
    "rec" <l: Label> "(" ")" ":" <t:Type> <block: TermBlock> => Term::RecursiveAnonymousFunction(l, Some(t), vec![], Box::new(Term::Block(block))),
    "lam" "(" <ls: LabelTypes> ")" <block: TermBlock> => Term::AnonymousFunction(ls, Box::new(Term::Block(block))),
    "lam" "(" ")" <block: TermBlock> => Term::AnonymousFunction(vec![], Box::new(Term::Block(block))),
};

FunctionCallTerm: Term = {
    <t:Label> "(" <ts: Terms> ")" => Term::FunctionCall(Box::new(Term::Variable(t)), ts),
    <t:TermBlock> "(" <ts: Terms> ")" => Term::FunctionCall(Box::new(Term::Block(t)), ts),
    <t:Label> "(" ")" => Term::FunctionCall(Box::new(Term::Variable(t)), vec![]),
    <t:TermBlock> "(" ")" => Term::FunctionCall(Box::new(Term::Block(t)), vec![]),
};

pub TermBlock: TermBlock = {
    "(" <ts: InsideTermBlock> ")" => Arc::new(ts),
};

pub Code : Term = <t: UnbracketedTermBlock> => Term::Block(t);

pub UnbracketedTermBlock : TermBlock = {
    <r""> => Arc::new(vec![]),
    <t: InsideTermBlock> => Arc::new(t)
    };

InsideTermBlock: Vec<Term> = {
    <t: Expr> => vec![t],
    <t: Expr> ";" => vec![t],
    <t: Expr> ";" <ts: InsideTermBlock> => merge_terms(t, ts),
}

Terms: Vec<Term> = {
    <r""> => vec![],
    <t: Expr> => vec![t],
    <t: Expr> "," => vec![t],
    <t: Expr> "," <ts: Terms> => merge_terms(t, ts),
}

pub Value: Value = {
    <s:r"[0-9]+"> => Value::VInt(i32::from_str(s).unwrap()),
    <s:r"[0-9]+\.[0-9]+"> => Value::VFloat(f32::from_str(s).unwrap()),
    "none" => Value::VNone,
    <b: Bool> => Value::VBool(b),
    <s:r#""(?:[^"\\]|\\.)*""#> => Value::VString(remove_quotes(s.to_string())), // https://stackoverflow.com/questions/249791/regex-for-quoted-string-with-escaping-quotes
    "$" <l: Label> => Value::VLabel(l),
};

Bool : bool = {
    "true" => true,
    "false" => false,
};

TypeVariable: String = "$"<s:r"([A-Z]+[A-Z0-9_]*)"> => s.to_string();
TypeList: Vec<Type> = {
    <l: Type> => vec![l],
    <l: Type> "," <ls: TypeList> => merge_types(l, ls),
};

Type: Type = { 
    "VAR" "(" <t: TypeVariable> ")" => Type::TypeVariable(t),
    "NONE" => Type::NoneType,
    "INT" => Type::IntType,
    "BOOL" => Type::BoolType,
    "FLOAT" => Type::FloatType,
    "STRING" => Type::StringType,
    "LABEL" => Type::LabelType,
    "ALL" => Type::AllType,
    "RECORD" "{" <l: LabelOccurrenceList> "}" => Type::RecordsType(l),
    "VARIANT" "[" <l: LabelOccurrenceList> "]" => Type::VariantType(l),
    "FUNCTION" "("  ")" "("  ")" => Type::FunctionType(vec![], Box::new(Type::NoneType)),
    "FUNCTION" "(" ")" "(" <to: Type> ")" => Type::FunctionType(vec![], Box::new(to)),
    "FUNCTION" "(" <ti: TypeList> ")" "("  ")" => Type::FunctionType(ti, Box::new(Type::NoneType)),
    "FUNCTION" "(" <ti: TypeList> ")" "(" <to: Type> ")" => Type::FunctionType(ti, Box::new(to)),
};

LabelOccurrenceList: Vec<(Label, FieldOccurrence)> = {
    <l: LabelOccurrence> => vec![l],
    <l: LabelOccurrence> "," <ls: LabelOccurrenceList> => merge_occurences(l, ls),
};

LabelType: (Label, Type) = {
    <l: Label> ":" <t: Type> => (l, t),
}

LabelTypes: Vec<(Label, Type)> = {
    <l: LabelType> => vec![l],
    <l: LabelType> "," <ls: LabelTypes> => merge_variant_types(l, ls),
}

LabelOccurrence: (Label, FieldOccurrence) = {
    <l: Label> ":" <f: FieldOccurrence> => (l, f),
};

FieldOccurrence: FieldOccurrence = {
    "-" => FieldOccurrence::Absent,
    "+" <t:Type> => FieldOccurrence::Present(t),
}

Label: String = <s:r"([a-z]+[a-z0-9_]*)"> => s.to_string();

Labels: Vec<String> = {
    <l: Label> => vec![l],
    <l: Label> "," <ls: Labels> => merge_labels(l, ls),
};

Element: (String, Box<Term>) = <s: Label> ":" <v: Term> => (s, Box::new(v));
Elements: Vec<(String, Box<Term>)> = {
    <e: Element> => vec![e],
    <e: Element> "," <es: Elements> => merge_elements(e, es),
};